// Code generated by typedcache. DO NOT EDIT.

package sample

import (
	"encoding/json"
	storages "github.com/reddec/storages"
	"sync"
)

// Two level storage for Sample
type CachedSampleStorage struct {
	cold storages.Storage   // persist storage
	hot  map[string]*Sample // cache storage
	lock sync.RWMutex
}

// Creates new storage for Sample with custom cache
func NewCachedSampleStorage(cold storages.Storage) *CachedSampleStorage {
	return &CachedSampleStorage{cold: cold, hot: make(map[string]*Sample)}
}

// Put single Sample encoded in JSON into cold and hot storage
func (cs *CachedSampleStorage) Put(key string, item *Sample) error {
	data, err := json.Marshal(item)
	if err != nil {
		return err
	}
	cs.lock.Lock()
	defer cs.lock.Unlock()
	err = cs.cold.Put([]byte(key), data)
	if err != nil {
		return err
	}
	cs.hot[key] = item
	return nil
}

/*
Get single Sample from hot storage and decode data as JSON.
If key is not in hot storage, the cold storage is used and obtained data is put to the hot storage for future cache
*/
func (cs *CachedSampleStorage) Get(key string) (*Sample, error) {
	cs.lock.RLock()
	item, exists := cs.hot[key]
	cs.lock.RUnlock()
	if exists {
		return item, nil
	}
	return cs.getMissed(key)
}

// Fetch all data from cold storage to the hot storage (warm cache)
func (cs *CachedSampleStorage) Fetch() error {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	return cs.cold.Keys(func(key []byte) error {
		data, err := cs.cold.Get(key)
		if err != nil {
			return err
		}
		var item Sample
		err = json.Unmarshal(data, &item)
		if err != nil {
			return err
		}
		cs.hot[string(key)] = &item
		return nil
	})
}

// Keys copied slice that cached in hot storage
func (cs *CachedSampleStorage) Keys() []string {
	cs.lock.RLock()
	defer cs.lock.RUnlock()
	var ans = make([]string, 0, len(cs.hot))
	for key := range cs.hot {
		ans = append(ans, key)
	}
	return ans
}

// Del key from hot and cold storage
func (cs *CachedSampleStorage) Del(key string) error {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	err := cs.cold.Del([]byte(key))
	if err != nil {
		return err
	}
	delete(cs.hot, key)
	return nil
}

func (cs *CachedSampleStorage) getMissed(key string) (*Sample, error) {
	cs.lock.Lock()
	defer cs.lock.Unlock()
	sitem, exists := cs.hot[key]
	if exists {
		return sitem, nil
	}
	data, err := cs.cold.Get([]byte(key))
	if err != nil {
		return nil, err
	}
	var item Sample
	err = json.Unmarshal(data, &item)
	if err != nil {
		return nil, err
	}
	cs.hot[key] = &item
	return &item, nil
}
